import os
import shutil
import geopandas as gpd
import pandas as pd

from matplotlib.backends.backend_pdf import PdfPages
import matplotlib.pyplot as plt
from matplotlib import gridspec
import matplotlib.patches as mpatches


def cleanup_temp_dir(temp_dir):
    """Delete the temporary directory after processing."""
    try:
        if os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)
    except Exception as e:
        print(f"Failed to remove temp directory {temp_dir}: {e}")

def split_gpkg(gdf_path, out_dir, field_name='name'):
    """Splits a GeoPackage into separate files based on a field name.
    
    - If the field value is missing, it assigns a unique number as the filename.
    - Deletes the input GPKG after splitting.
    - Returns the path to the output directory.
    """
    os.makedirs(out_dir, exist_ok=True)

    # Read the input GPKG
    gdf = gpd.read_file(gdf_path)

    # Ensure the field exists
    if field_name not in gdf.columns:
        raise ValueError(f"Field '{field_name}' not found in the GeoPackage.")

    # Get unique values, replacing missing ones with an empty string
    unique_values = gdf[field_name].fillna("").astype(str).unique()

    for i, value in enumerate(unique_values):
        # Use a number if the field value is empty
        if value.strip() == "":
            safe_value = f"unnamed_{i}"
        else:
            # Make sure filename is safe
            safe_value = value.replace(" ", "_").replace("/", "_").replace("\\", "_")

        # Define output path
        out_path = os.path.join(out_dir, f"{safe_value}.gpkg")

        # Save subset of the data
        gdf[gdf[field_name] == value].to_file(out_path, driver="GPKG")

        print(f"Saved: {out_path}")

    # Delete the original input file
    os.remove(gdf_path)
    print(f"Deleted input file: {gdf_path}")

    # Return the output folder path
    return os.path.abspath(out_dir)

plt.rcParams.update({
    'font.family': 'DejaVu Sans',
    'font.size': 11,
    'axes.titlesize': 16,
    'axes.titleweight': 'bold',
})

def save_validation_report(metrics: dict, plot_fig, save_path: str):

    def rename_and_format_metrics(metric_dict):
        name_map = {
            "RMSE": "RMSE (Root Mean Square Error)",
            "MAE": "MAE (Mean Absolute Error)",
            "NMAD": "NMAD (Normalized Median Absolute Deviation)",
            "MR": "MR (Mean Residual)",
            "STDE": "STDE (Standard Deviation of Error)",
            "Median Error": "Median Residual",
            "LE90": "LE90 (90% Linear Error)",
            "LE95": "LE95 (95% Linear Error)",
            "Max Over": "Max Overestimate",
            "Max Under": "Max Underestimate",
            "R2": "R² (Coefficient of Determination)"
        }
        return {
            name_map.get(k, k): round(v, 3) if isinstance(v, (float, int)) else v
            for k, v in metric_dict.items()
        }

    def add_footer(fig, text="Generated by Validation Suite | March 2025"):
        fig.text(0.5, 0.02, text, ha='center', fontsize=8, color='gray')

    description_text = [
        "\u2022 RMSE (Root Mean Square Error): Square root of average squared differences \n between predicted and true values. Sensitive to large errors.",
        "\u2022 MAE (Mean Absolute Error): Average of absolute errors.\n Less sensitive to outliers than RMSE.",
        "\u2022 NMAD (Normalized Median Absolute Deviation): Robust dispersion estimator.",
        "\u2022 MR (Mean Residual): Average bias. \nIndicates systematic over/underestimation.",
        "\u2022 STDE (Standard Deviation of Error): Spread of residuals (non-robust).",
        "\u2022 Median Residual: Median of residuals.",
        "\u2022 LE90 / LE95: 90th and 95th percentiles\n of absolute errors.",
        "\u2022 Max Overestimate / Underestimate: Maximum positive/negative residual.",
        "\u2022 R² (Coefficient of Determination): Fit quality between\n prediction and reference (1 = perfect)."
    ]

    with PdfPages(save_path) as pdf:
        # Page 1: Plot
        add_footer(plot_fig)
        pdf.savefig(plot_fig)
        plt.close(plot_fig)

        # Page 2: Definitions (formatted)
        fig_defs = plt.figure(figsize=(8.5, 11))
        gs = gridspec.GridSpec(1, 1)
        ax = fig_defs.add_subplot(gs[0])
        ax.axis('off')
        fig_defs.subplots_adjust(left=0.1, right=0.9, top=0.92, bottom=0.1)

        ax.text(0, 1, "Validation Metrics - Definitions", fontsize=16, fontweight='bold', va='top')
        y_pos = 0.95
        for line in description_text:
            ax.text(0, y_pos, line, fontsize=11, va='top')
            y_pos -= 0.045

        add_footer(fig_defs)
        pdf.savefig(fig_defs)
        plt.close(fig_defs)

        # Page 3: Global metrics
        global_metrics = rename_and_format_metrics(metrics['global'])
        fig_global = _render_metrics_table(global_metrics, title="Global Validation Metrics")
        add_footer(fig_global)
        pdf.savefig(fig_global)
        plt.close(fig_global)

        # Per-raster pages
        for raster_name, stats in metrics['per_raster'].items():
            raster_metrics = rename_and_format_metrics(stats)
            fig_raster = _render_metrics_table(raster_metrics, title=f"Metrics for {raster_name}")
            add_footer(fig_raster)
            pdf.savefig(fig_raster)
            plt.close(fig_raster)

def _render_metrics_table(metrics: dict, title: str):
    fig, ax = plt.subplots(figsize=(8.5, 11))
    ax.axis('tight')
    ax.axis('off')

    table_data = [(k, str(v)) for k, v in metrics.items()]
    col_labels = ["Metric", "Value"]

    table = ax.table(
        cellText=table_data,
        colLabels=col_labels,
        colWidths=[0.6, 0.3],
        cellLoc='left',
        loc='center'
    )

    table.auto_set_font_size(False)
    table.set_fontsize(11)
    table.scale(1, 1.5)

    for (row, col), cell in table.get_celld().items():
        if row == 0:
            cell.set_text_props(weight='bold')
            cell.set_facecolor("#f0f0f0")
        else:
            if row % 2 == 0:
                cell.set_facecolor('#f9f9f9')
            else:
                cell.set_facecolor('#ffffff')
            if col == 0:
                cell.get_text().set_ha('left')
            else:
                cell.get_text().set_ha('right')
        cell.set_linewidth(0.5)

    ax.set_title(title, fontweight='bold', fontsize=16, pad=30)
    fig.tight_layout()
    return fig